================================================================================================================

##1강. 클래스와 데이터

- 클래스란? 현실 세계의 개념을 프로그램에 정의하는 것이다.
- 인스턴스란? 클래스를 사용해서 실제 메모리에 만들어진 실체(by New ~~ ). 메모리에 공간이 할당되어야 쓸 수 있다.
- 객체를 생성하면 자바는 인스턴스의 참조값을 반환한다.
- 자바에서의 대입 : 변수에 들어있는 값을 복사해서 전달한다(상수든 참조값이든).
- Student[] studentArr = new int[1]; Student student1 = new Student();
=> studentArr[0] = student1; //인스턴스 자체가 복사된 것이 아니라! 참조값이 복사된 것이다.

c.f) 객체 vs 인스턴스
=> 실무에서는 사실상 동일한 의미로서 사용된다. 굳이 따지자면..

객체 : 클래스에서 정의한 속성과 기능을 가진 실체.
인스턴스 : 클래스에서 나온 실체(좀 더 관계에 초점을 맞춘 개념). ex) student1은 Student 클래스로부터 생성되었으므로 Student의 인스턴스야.

================================================================================================================

##2강. 기본형과 참조형

- 참조형이랑? 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입. ex) 객체, 배열

c.f) String
=> String은 Java에서 특별하게 편의 기능을 제공하는 클래스(참조형)

- Java는 항상 변수의 값을 복사해서 대입한다!
=> 참조형의 경우, 실제 사용하는 객체가 아니라 객체의 위치를 가리키는 참조값만 복사한다.
- 기본형과 참조형의 메서드 호출 : 메서드 매개변수에 변수의 값을 넣어도 값만 복사되는 것.
=> 기본형 - 해당 값이 복사되어 전달. 메서드 내부에서 매개변수의 값을 변경해도, 호출자의 변수 값에는 영향이 없다.
=> 참조형 - 참조값이 복사되어 전달. 메서도ㅡ 내부에서 매개변수로 전달된 객체의 멤버 변수를 변경하면, 호출자의 객체도 변경된다.

c.f) Garbage Collection
아무도 참조하지 않는 인스턴스가 있으면 JVM의 GC가 더 이상 사용하지 않는 인스턴스라 판단하고,
해당 인스턴스를 자동으로 메모리에서 제거해준다 => 메모리 부족 오류 방지.
How? 해당 객체를 참조하는 곳이 있는지 없는지로 판단.

================================================================================================================

##3강. 객체지향 프로그래밍

- 절차지향 : 프로그램의 흐름을 순차적으로 따르며 처리하는 방식.
- 객체지향 : 실제 세계의 사물이나 사건을 객체로 보고, 객체들 간의 상호작용을 중심으로 프로그래밍하는 방식.
=> 데이터와 기능을 하나로 묶어서 사용
- 인스턴스 생성하면, 인스턴스 내에 멤버변수 & 메서드가 같이 존재하여 메모리에 올라간다.
- 캡슐화 : 속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것.

================================================================================================================

##4강. 생성자

- 생성자가 필요한 이유 : 메서드 호출로도 인스턴스 생성이 가능하지만 속성과 기능을 한 곳에 두는 것이 더 좋기 때문에(객체지향적 관점),
클래스 자기 자신의 데이터를 변경하는 기능(메서드)를 제공하는 것이 좋다.
- this : 인스턴스 자신의 참조값을 가리킴. 멤버 변수에 접근하려면 앞에 'this.' 붙여주기.
- 객체를 생성할 때 직접 정의한 생성자가 있다면 직접 정의한 생성자를 반드시 호출해야 한다.

================================================================================================================

##5강. 패키지

================================================================================================================

##6강. 접근 제어자

- private < default < protected < public
- 하나의 자바 파일에 public 클래스는 하나만 등장할 수 있다.(파일명과 이름이 일치하는 Class)
- 캡슐화 : 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만 노출하고 나머지는 모두 내부로 숨기는 것.

================================================================================================================

##7강. 자바 메모리 구조와 static

- 자바 메모리 구조 : 메서드 영역 - 클래스 정보를 보관 / 스택 영역 - 실제 프로그램이 실행되는 영역 / 힙 영역 - 객체(인스턴스)가 생성되는 영역
자바가 실행되면 JVM이라는게 이런 메모리 구조를 내부에서 가지고 동작함.
- 메서드 영역 : 프로그램을 실행하는데 필요한 공통 데이터를 관리하며, 프로그램의 모든 영역에서 공유된다.
    클래스 정보, static 영역, 런타임 상수 풀
- 스택 영역 : 자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
- 힙 영역 : 객체와 배열이 생성되는 영역이다. 가비지 컬렉션이 이루어지는 주요 영역으로, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

- static 키워드 : 공용으로 사용할 수 있도록 해준다. static이 붙은 멤버 변수는 메서드 영역에서 관리한다.
- 멤버 변수의 종류 : 인스턴스 변수, 클래스 변수
    인스턴스 변수 : 인스턴스를 만들 때 마다 새로 만들어진다.
    클래스 변수 : 자바 프로그램을 시작할 때 딱 1개가 만들어진다. static이 붙는다. 클래스에서 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있다.

================================================================================================================

##8강. final

- final을 지역 변수에 설정할 경우 최초 한번만 할당할 수 있다.
- final을 지역 변수 선언시 바로 초기화한 경우 이미 값이 할당되었기 때문에 값을 할당할 수 없다.
- 매개변수에 final이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없다.
- final을 필드에 사용할 경우, 해당 필드는 생성자를 통해서 한번만 초기화될 수 있다.

- 상수 : 변하지 않고, 항상 일정한 값을 갖는 수 = 단 하나만 존재하는 변하지 않는 고정된 값
=> static final 키워드를 사용한다.
- 상수는 런타임에 변경할 수 없다. 상수를 변경하려면 프로그램을 종료하고, 코드를 변경한 다음에 프로그램을 다시 실행해야 한다.

================================================================================================================

##9강. 상속

- 부모는 자식 클래스에 접근할 수 없지만, 자식 클래스는 부모 클래스에 접근할 수 있음.
- 자식 클래스를 생성하면, 상속관계에 있는 부모까지 포함해서 인스턴스를 생성한다.
=> 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
- 메서드 호출 시, 호출하는 변수의 타입(클래스)을 기준으로 선택한다.
- 자식 클래스의 인스턴스면 자식 클래스의 메서드를 먼저 찾고, 없을 시에 부모 클래스의 메서드를 찾는다.
- 상속의 효과 : 코드 중복은 줄이고, 편리하게 확장(자식)할 수 있다.

- 메서드 오버라이딩 조건
    메서드 이름이 같아야 한다.
    매개변수 타입, 순서, 개수가 같아야 한다.
    반환 타입이 같아야 한다.
    접근제어자가 상위 클래스의 메서드 보다 제한적이어선 안된다.
    static, final, private이 붙은 메서드는 오버라이딩이 불가능하다.

- super : 상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.(규칙)
상속 관계에서 부모 생성자를 호출할 때 super을 사용한다.
- 부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우에는 super()를 생략할 수 있다.

- 예외로 생성자 첫줄에 this를 사용할 수는 있다. 하지만 super는 자식의 생성자 안에서 언젠가는 반드시 호출해야 한다.

================================================================================================================

##10강. 다형성1

- 다형성 : 한 객체가 여러 타입의 객체로 취급될 수 있는 능력.
- 다형적 참조 : 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능
    다양한 형태를 참조할 수 있다 = 부모 타입은 자신을 기준으로 모든 자식 인스턴스를 참조할 수 있다.
- 상속 관계는 부모로만 찾아서 올라갈 수 있으므로, 자식 타입의 메서드를 호출할 수 없다. => 컴파일 오류

- 업캐스팅 : 부모타입으로 변경 / 다운캐스팅 : 자식 타입으로 변경
- 다운캐스팅을 통해 일시적으로 부모타입을 자식타입으로 변환 후 자식타입의 메서드를 호출할 수는 있다.
- 업캐스팅은 생략 가능하지만, 다운캐스팅은 생략할 수 없다.(업캐스팅은 매우 자주 사용하므로 생략을 권장)
- 메모리 상에 자식타입이 존재하지 않는 경우, 다운캐스팅은 불가능하다 => 런타임 에러
(ex. Parent parent = new Parent()로 생성 시, CHILd 인스턴스는 메모리에 없음)
- 업캐스팅이 안전하고 다운캐스팅이 위험한 이유
: 자식 인스턴스를 생성하면 상위 부모 타입은 모두 함께 생성되므로, 위로만 타입을 변경하는 업캐스팅은 메모리 상에 인스턴스가 모두 존재하기 때문에 안전하다.
반면 다운캐스팅의 경우 자식 타입은 생성되지 않으므로, 인스턴스에 존재하지 않는 하위 타입으로 캐스팅되는 문제가 발생할 수 있다.

- instanceof 키워드 : 변수가 참조하는 인스턴스의 타입을 확인한다.
ex. A instanceof B : B 타입에 A 타입이 들어갈 수 있는지?
new Parent() instanceof Parent => true
new Child() instanceof Parent => true
new Parent() instanceof Child => false

- 메서드 오버라이딩 : 기존 기능을 하위 타입에서 새로운 기능으로 재정의한다.
- 메서드 오버라이딩의 진짜 힘은 다형성과 함께 사용할 때 나타난다.
=> 오버라이딩된 메서드가 항상 우선권을 가진다.

================================================================================================================

##11강. 다형성2

- 추상 클래스 : 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스. abstract 키워드를 사용한다.
- 추상 메서드 : 추상적인 개념을 제공하는 메서드로, 부모 클래스를 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있다.
(ex. public abstract void sound();)
- 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
- 추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩해서 사용해야 한다. => 컴파일 오류

- 순수 추상 클래스 : 모든 메서드가 추상 메서드인 추상 클래스.
    인스턴스를 생성할 수 없다.
    상속 시, 자식은 모든 메서드를 오버라이딩해야 한다.
    주로 다형성을 위해 사용된다.
- 자바는 순수 추상 클래스를 더 편리하게 사용할 수 있는 interface라는 기능을 제공한다.

- 상속 vs 구현
부모 클래스의 기능을 자식 클래스가 상속 받을 때 클래스는 상속받는다고 표현하지만, 부모 인터페이스의 기능을 자식이 상속받을 때는 인터페이스를 구현한다고 표현한다.
상속은 이름 그대로 부모의 기능을 물려 받는 것이 목적이지만, 인터페이스는 물려 받을 수 있는 기능이 없다.
오히려 인터페이스에 정의한 모든 메서드를 자식이 오버라이딩해서 기능을 구현해야 하므로, 구현한다고 표현한다.

- 인터페이스를 사용해야 하는 이유
    제약 : 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현해라는 규약(제약)을 주는 것이다.
          순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워넣을 수 있는데, 인터페이스를 사용해서 이을 방지 할 수 있다.
    다중 구현 : 인터페이스는 부모를 여러명 두는 다중 구현(다중 상속)이 가능하다.

================================================================================================================

##12. 다형성과 설계
- 다형성의 본질
    인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다. ex) 클라이언트는 그대로 있지만 타는 자동차는 변경 가능.
    다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.
    클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

- 역할과 구현을 분리
    실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있다.
    유연하고 변경이 용이하다.
    확장 가능한 설계가 가능하며 클라이언트에 영향을 주지 않으면서 변경이 가능하다.
    => 인터페이스를 안정적으로 잘 설계하는 것이 중요.
    but, 역할(인터페이스) 자체가 바뀌어야 한다면, 클라이언트&서버 모두 큰 변경이 발생한다.

- OCP(Open-Closed Principle)
    Open for extension : 새로운 기능의 추가나 변경 사항이 생겼을 때, 기존 코드는 확장할 수 있어야 한다.
    Closed for modification : 기존의 코드는 수정되지 않아야 한다.

================================================================================================================